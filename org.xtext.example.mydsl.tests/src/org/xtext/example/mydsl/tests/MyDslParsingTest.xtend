/*
 * generated by Xtext 2.23.0
 */
package org.xtext.example.mydsl.tests

import com.google.inject.Inject
import java.util.Dictionary
import java.util.Hashtable
import java.util.List
import org.eclipse.emf.common.util.EList
import org.eclipse.xtext.testing.InjectWith
import org.eclipse.xtext.testing.extensions.InjectionExtension
import org.eclipse.xtext.testing.util.ParseHelper
import org.junit.jupiter.api.Assertions
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.^extension.ExtendWith
import org.xtext.example.mydsl.myDsl.Addition
import org.xtext.example.mydsl.myDsl.Association
import org.xtext.example.mydsl.myDsl.Boolean
import org.xtext.example.mydsl.myDsl.Const
import org.xtext.example.mydsl.myDsl.Div
import org.xtext.example.mydsl.myDsl.JsonInteger
import org.xtext.example.mydsl.myDsl.JsonObject
import org.xtext.example.mydsl.myDsl.JsonString
import org.xtext.example.mydsl.myDsl.JsonValue
import org.xtext.example.mydsl.myDsl.Load
import org.xtext.example.mydsl.myDsl.Minus
import org.xtext.example.mydsl.myDsl.Operation
import org.xtext.example.mydsl.myDsl.Operation
import org.xtext.example.mydsl.myDsl.Programme
import org.xtext.example.mydsl.myDsl.Save
import org.xtext.example.mydsl.myDsl.Time
import org.xtext.example.mydsl.myDsl.Variable
import org.xtext.example.mydsl.myDsl.JsonArray
import java.lang.reflect.Array
import org.xtext.example.mydsl.myDsl.Expression
import org.xtext.example.mydsl.myDsl.Assignement

@ExtendWith(InjectionExtension)
@InjectWith(MyDslInjectorProvider)
class MyDslParsingTest {
	@Inject
	ParseHelper<Programme> parseHelper

	@Test
	def void testSimpleVariable() {
		val result = parseHelper.parse('''
			a
		''')
		val variable = result.statements.get(0) as Variable
		Assertions.assertEquals(variable.nodes.get(0), "a")
	}

	@Test
	def void testLoadPrimitiveFunction() {
		val result = parseHelper.parse('''
			load( "pathTo.json" , varName )
		''')
		val loadPrimitive = result.statements.get(0) as Load
		Assertions.assertEquals(loadPrimitive.getPath(), "pathTo.json")
		Assertions.assertEquals(loadPrimitive.varName, "varName")

	}

	@Test
	def void testSimpleConst() {
		val result = parseHelper.parse('''
			1
		''')
		val const = result.statements.get(0) as Const
		Assertions.assertEquals(const.value, 1)
	}

	@Test
	def void testSavePrimitive() {
		val result = parseHelper.parse('''
			save( "pathTo.json" , varName )
		''')
		val SavePrimitive = result.statements.get(0) as Save
		Assertions.assertEquals(SavePrimitive.getPath(), "pathTo.json")
		Assertions.assertEquals(SavePrimitive.varName, "varName")

	}

	@Test
	def void testConstAddition() {
		val result = parseHelper.parse('''
			1 + 2 
		''')
		val addition = result.statements.get(0) as Operation
		Assertions.assertEquals((addition.left as Const).value, 1)
		Assertions.assertEquals((addition.right as Const).value, 2)
	}

	@Test
	def void testVarAddition() {
		val result = parseHelper.parse('''
			a + b 
		''')
		val addition = result.statements.get(0) as Operation
		Assertions.assertEquals((addition.left as Variable).nodes.get(0), "a")
		Assertions.assertEquals((addition.right as Variable).nodes.get(0), "b")
	}

	@Test
	def void testSubstraction() {
		val result = parseHelper.parse('''
			a - 1 
		''')
		val sub = result.statements.get(0) as Operation
		sub.op as Minus
		Assertions.assertEquals((sub.left as Variable).nodes.get(0), "a")
		Assertions.assertEquals((sub.right as Const).value, 1)
	}

	@Test
	def void testTime() {
		val result = parseHelper.parse('''
			a * 1 
		''')
		val time = result.statements.get(0) as Operation
		time.op as Time
		Assertions.assertEquals((time.left as Variable).nodes.get(0), "a")
		Assertions.assertEquals((time.right as Const).value, 1)
	}

	@Test
	def void testDiv() {
		val result = parseHelper.parse('''
			a / 1 
		''')
		val div = result.statements.get(0) as Operation
		div.op as Div // smoke test
		Assertions.assertEquals((div.left as Variable).nodes.get(0), "a")
		Assertions.assertEquals((div.right as Const).value, 1)
	}

	@Test
	def void testcomplexExpression() {
		val result = parseHelper.parse('''
			(a + 1) * 2 
		''')

		val multExp = result.statements.get(0) as Operation
		multExp.op as Time
		(multExp.left as Operation).op as Addition
		Assertions.assertEquals((multExp.right as Const).value, 2)
	}

	@Test
	def void testOperationWithParenthesis() {
		val result = parseHelper.parse('''
			(a + 1) * 2 
		''')
		Assertions.assertEquals(result.statements.size, 1)
		val multExpr = result.statements.get(0) as Operation
		(multExpr.left as Operation).op as Addition
		Assertions.assertEquals((multExpr.right as Const).value, 2)
	}

	@Test
	def void testMultipleLineStatement() {
		val result = parseHelper.parse('''
			load( "pathTo.json" , varName )
			1 * ( a / 5 ) 
			save("path2.json" , varName)
		''')
		// smoke test 
		val load = result.statements.get(0) as Load
		var multExpr = result.statements.get(1) as Operation
		var save = result.statements.get(2) as Save
	}

	@Test
	def void testSimpleJSONObjectExpression() {
		val result = parseHelper.parse('''
			{ "string"  : "ValueA", "integer": 10 , "booleanTrue": true , "booleanFalse" : false } 
		''')
		Assertions.assertEquals(result.statements.size(), 1)
		val jsonObject = result.statements.get(0) as JsonObject
		val dico = new Hashtable<String, JsonValue>()
		getKeyValueInJsonObject(jsonObject, dico)
		Assertions.assertEquals((dico.get("string") as JsonString).value, "ValueA")
		Assertions.assertEquals((dico.get("integer") as JsonInteger).value, 10)
		Assertions.assertEquals((dico.get("booleanTrue") as Boolean).value, "true")
		Assertions.assertEquals((dico.get("booleanFalse") as Boolean).value, "false")

	}

	protected def void getKeyValueInJsonObject(JsonObject jsonObject, Hashtable<String, JsonValue> dico) {
		val iterator = jsonObject.associations.iterator()
		while (iterator.hasNext()) {
			val object = iterator.next()
			dico.put(object.key, object.value)

		}
	}

	@Test
	def void testEmptyJsonOBject() {
		val result = parseHelper.parse('''
			{ } 
		''')
		Assertions.assertEquals(result.statements.size, 1)
		val jsonObject = result.statements.get(0) as JsonObject
		Assertions.assertTrue(jsonObject.associations.isEmpty())
	}

	@Test
	def void testJsonContainingArray() {
		val result = parseHelper.parse('''
			{ "array" : [ 1 , "a"  ] } 
		''')
		val jsonObject = result.statements.get(0) as JsonObject
		val dico = new Hashtable<String, JsonValue>()
		getKeyValueInJsonObject(jsonObject, dico)
		Assertions.assertTrue(((dico.get("array") as JsonArray).value.get(0) as JsonInteger).value == 1)
		Assertions.assertTrue(((dico.get("array") as JsonArray).value.get(1) as JsonString).value == "a")

	}

	@Test
	def void testSimpleJsonAssignement() {
		val result = parseHelper.parse('''
			json.intAttribute = 1
		''')
		Assertions.assertFalse(result instanceof Variable)
		val assignement = result.statements.get(0) as Assignement
		Assertions.assertEquals((assignement.variable as Variable).nodes.get(0), "json")
		Assertions.assertEquals((assignement.variable as Variable).nodes.get(1), "intAttribute")
		Assertions.assertTrue(assignement.value instanceof Expression)

	}

	@Test
	def void testBadJsonObjectShouldRaiseParsingException() {
		val result = parseHelper.parse('''
			{ { } 
		''')
	}
}
